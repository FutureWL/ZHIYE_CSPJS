以下是几个使用C++实现穷举算法的示例场景，分别展示不同类型问题中穷举算法的应用：

### 示例一：找出1到100之间的所有质数（素数）
```cpp
#include <iostream>
#include <cmath>
using namespace std;

// 判断一个数是否为质数的函数
bool isPrime(int num) {
    if (num < 2) {
        return false;
    }
    for (int i = 2; i <= sqrt(num); i++) {
        if (num % i == 0) {
            return false;
        }
    }
    return true;
}

int main() {
    cout << "1到100之间的质数有：" << endl;
    for (int n = 1; n <= 100; n++) {
        if (isPrime(n)) {
            cout << n << " ";
        }
    }
    cout << endl;
    return 0;
}
```

**代码解释**：
- **`isPrime` 函数**：这个函数用于判断给定的整数 `num` 是否为质数。首先排除小于 `2` 的数，因为质数定义是大于 `1` 且除了 `1` 和它自身外，不能被其他自然数整除的数。然后通过一个 `for` 循环从 `2` 开始到该数的平方根（使用 `sqrt` 函数获取，减少不必要的循环次数）遍历，如果发现该数能被这个区间内的某个数整除（`num % i == 0`），那就不是质数，返回 `false`；如果遍历完都没有这样的数，就返回 `true`。
- **`main` 函数**：通过一个 `for` 循环遍历从 `1` 到 `100` 的所有整数，对于每个整数调用 `isPrime` 函数进行判断，如果是质数就输出该数，最终就得到了 `1` 到 `100` 之间所有的质数列表。

### 示例二：百钱买百鸡问题
在我国古代数学著作《张邱建算经》中有一道著名的“百钱买百鸡”问题，公鸡每只五钱，母鸡每只三钱，小鸡三只一钱，用一百钱买一百只鸡，问公鸡、母鸡、小鸡各买多少只？

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "百钱买百鸡的可能方案如下：" << endl;
    for (int x = 0; x <= 20; x++) {  // 公鸡数量，最多20只（100钱全买公鸡最多20只）
        for (int y = 0; y <= 33; y++) {  // 母鸡数量，最多33只（100钱全买母鸡最多33只）
            int z = 100 - x - y;  // 小鸡数量，由总数100只减去公鸡和母鸡数量得到
            if (5 * x + 3 * y + z / 3 == 100 && z % 3 == 0) {
                cout << "公鸡：" << x << " 只，母鸡：" << y << " 只，小鸡：" << z << " 只" << endl;
            }
        }
    }
    return 0;
}
```

**代码解释**：
- 采用两层嵌套的 `for` 循环来穷举公鸡和母鸡的数量，公鸡数量 `x` 的取值范围是从 `0` 到 `20`（因为总共 `100` 钱，一只公鸡 `5` 钱，所以最多买 `20` 只公鸡），母鸡数量 `y` 的取值范围是从 `0` 到 `33`（同理，一只母鸡 `3` 钱，最多买 `33` 只母鸡）。
- 对于每一组 `x` 和 `y` 的取值，通过 `z = 100 - x - y` 计算出小鸡的数量，然后判断是否满足总钱数是 `100` 钱的条件（`5 * x + 3 * y + z / 3 == 100`）以及小鸡数量必须是 `3` 的倍数（`z % 3 == 0`），如果这两个条件都满足，就输出这一组公鸡、母鸡、小鸡的数量，代表一种可行的购买方案。

### 示例三：密码破解（简单示例，假设密码是4位数字）
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string password = "1234";  // 假设的正确密码，实际应用中这是未知的
    cout << "开始尝试破解密码..." << endl;
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            for (int k = 0; k < 10; k++) {
                for (int l = 0; l < 10; l++) {
                    string guess = to_string(i) + to_string(j) + to_string(k) + to_string(l);
                    if (guess == password) {
                        cout << "密码破解成功，密码是：" << guess << endl;
                        return 0;
                    }
                }
            }
        }
    }
    cout << "密码破解失败" << endl;
    return 0;
}
```

**代码解释**：
- 通过四层嵌套的 `for` 循环来穷举所有 `4` 位数字的组合情况，每一层循环变量分别代表密码的每一位数字，取值范围都是从 `0` 到 `9`。
- 对于每一种组合情况，通过 `to_string` 函数将数字转换为字符串，然后拼接起来形成一个 `4` 位的字符串 `guess`，代表猜测的密码。如果这个猜测的密码和预先设定的正确密码（这里只是为了示例假设已知，实际情况是未知的）相等，就输出破解成功的信息并结束程序；如果穷举完所有可能的组合都没有匹配成功，就输出破解失败的信息。

穷举算法就是通过这种逐一列举所有可能情况的方式来寻找满足特定条件的解，不过在实际应用中，要考虑穷举范围是否过大导致效率低下等问题，有时候需要结合一些优化策略来缩小穷举空间或者提前判断某些情况无需继续穷举等。 


